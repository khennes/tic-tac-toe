(function() {
    'use strict';
    window.onload = initialize;

    /**
     * Define global variables.
     **/

    var game = false,
        currentPlayer,
        computer = 'O',
        user = 'X',
        draw = 'draw',
        gamestate,
        movesMade = {},
        gameboard = document.getElementById('gameboard'),
        userMessage = document.getElementById('message'),
        possibleWins = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6],
                        [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ],
        SQUARES = gameboard.childNodes.length;


    /**
     * Define gameboard's initial (empty) state;
     **/

    function initialize() {
        movesMade[computer] = [];
        movesMade[user] = [];
        currentPlayer = null;

        // represent current state of gameboard with 'X', 'O', and '-'
        gamestate = ['-', '-', '-', '-', '-', '-', '-', '-', '-'];
        userMessage.innerHTML = "Click 'Play game' to start";

        // clear the gameboard DOM element
        for (var i = 0; i < SQUARES; i++) {
            gameboard.childNodes[i].innerHTML = "";
        }
    }
    

    /**
     * Allow user to reset game by clicking "Restart".
     **/

    var restartButton = document.getElementById('restart');
    restartButton.addEventListener('click', function(e) {
        game = false;
        window.setTimeout(initialize, 700);
    });


    /**
     * Start game when user clicks 'Play game'.
     **/

    var playButton = document.getElementById('play');
    playButton.addEventListener('click', function(e) {
        if (game === false && currentPlayer === null) {
            game = true;
            currentPlayer = computer;
            userMessage.innerHTML = "";
            window.setTimeout(seedBoard, 400);
        }
    });


    /**
     * Computer pseudorandomly chooses a corner or middle square to start.
    */

    function seedBoard() {
        var randomCorner = Math.floor(Math.random()*4),
            corners = {
                0: 's0',
                1: 's2',
                2: 's4',
                3: 's6',
                4: 's8'
            },
            firstMove = document.getElementById(corners[randomCorner]);
        makeMove(computer, firstMove);
        currentPlayer = user;
    }


    /**
     * Implement current player's move:
     * (1) Print to the gameboard DOM element
     * (2) Update global gamestate 
     * (3) Add square to player's list of moves made 
     *
     * If player has made at least 3 moves, call checkWinner() 
     * to check the gameboard for a possible win.
     **/

    function makeMove(player, nextMove) {
        var winner,
            moveIndex;

        moveIndex = parseInt(nextMove.id.replace('s', ''));
        nextMove.innerHTML = player;
        gamestate[moveIndex] = player;
        movesMade[player].push(moveIndex);

        if (movesMade[player].length >= 3) {
            winner = checkWinner(gamestate);
            if (winner) endGame(winner);
        }
    }


    /**
     * Event delegation: Listen for user's move.
     **/

    gameboard.addEventListener('click', function(e) {
        if (e.target && currentPlayer === user) {
            userMessage.innerHTML = "";
            var nextMove = document.getElementById(e.target.id),
                openSquares = getOpenSquares(gamestate),
                moveIndex = nextMove.id.replace('s', '');

            if (gamestate[moveIndex] === '-') {
                makeMove(user, nextMove);
                currentPlayer = computer;
                computerMove();
            }
        }
    });


    /**
     * Return an array of available moves.
     * 'currentGamestate' param is either the global gamestate 
     * or a speculative gamestate generated by the negamax() function.
     **/

    function getOpenSquares(currentGamestate) {
        var i, openSquares = [];

        for (i = 0; i < SQUARES; i++) {
            if (currentGamestate[i] === "-") {
                openSquares.push(i);
            }
        }
        return openSquares;
    }


    /**
     * Check gameboard for a winning three-in-a-row.
     *
     * Loop through the 8 possible winning triplets, where 'a' is the first
     * square in a winning triplet, 'b' is the second square, & 'c' is the third.
     *
     * If a winner is found (ie, all three squares are occupied by either
     * an 'X' or an 'O'), return 'computer' or 'user' (whether or not the 
     * gameboard is full). If the gameboard is full and no winner is found, 
     * return 'draw'. Otherwise, the function returns no value & the game continues.
     **/

    function checkWinner(currentGamestate) {
        var a, b, c, win,
            WINS = possibleWins.length,
            openSquares;

        for (win = 0; win < WINS; win++) {
            a = currentGamestate[possibleWins[win][0]];
            b = currentGamestate[possibleWins[win][1]];
            c = currentGamestate[possibleWins[win][2]];

            if (a === b && a === c && a === computer) {
                return computer;
            } else if (a === b && a === c && a === user) {
                return user;
            }
        }
        openSquares = getOpenSquares(currentGamestate);
        if (openSquares.length === 0) {
            return draw;
        }
    }


    /**
     * Report game result to user.
     **/

    function endGame(result) {
        game = false;
        if (result === computer) {
            userMessage.innerHTML = "Game over. You lose :)";
        } else if (result === user) {
            userMessage.innerHTML = "Game over. You win :(";
        } else if (result === draw) {
            userMessage.innerHTML = "Game over. It's a draw.";
        }
    }
    

    /**
     * Generate Computer's next move by invoking negamax(). 
     *
     * Fetch a list of open squares and create a copy of the global
     * gamestate array. For each square, make the move and call negamax() on it,
     * then undo the move.
     *
     * Then, loop through the list of returned scores, this time calling negamax() 
     * only on the squares given the best score. If the move leads to an immediate
     * win or an immediate loss, make it; otherwise, make the next best possible move.
     **/

    function computerMove() {
        var i,
            winner,
            openSquares,
            OPEN,
            gamestateCopy,
            score,
            scores = [],
            bestScore = -9999,
            bestMove = null,
            nextMove;

        // check for a winner or tie. If neither, continue.
        winner = checkWinner(gamestate);
        if (winner) endGame(winner);
        else {
            openSquares = getOpenSquares(gamestate);
            OPEN = openSquares.length;
            gamestateCopy = gamestate;

            for (i = 0; i < OPEN; i++) {

                // make speculative move
                gamestateCopy[openSquares[i]] = computer;

                // compute score & append to 'scores' 
                score = negamax(gamestateCopy, computer, 7);
                scores.push(score);

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = openSquares[i];  // default
                }

                // undo speculative move
                gamestateCopy[openSquares[i]] = '-';
            }

            // repeat the above procedure for all squares given the best score;
            // check if the move will lead to either an immediate win or an immediate loss
            for (i = 0; i < OPEN; i++) {
                if (scores[i] === bestScore) {
                    gamestateCopy[openSquares[i]] = computer;

                    if (negamax(gamestateCopy, computer, 0) === 1) {
                        console.log("immediate win");
                        bestMove = openSquares[i];
                        break;
                    } else if (negamax(gamestateCopy, computer, 1) !== -1) {
                        console.log("block a loss");
                        bestMove = openSquares[i];
                    } else if (negamax(gamestateCopy, computer, 1) === 1) {
                        console.log("make the next best move");
                        bestMove = openSquares[i];
                    }

                    gamestateCopy[openSquares[i]] = '-';
                }
            }
            
            nextMove = document.getElementById('s' + bestMove);
            window.setTimeout(makeMove, 800, computer, nextMove);
            currentPlayer = user;
        }
    }


    /**
     * Negamax algorithm:
     * Calculate the utility of each available square.
     *
     * Base case: There are no plies left to explore if checkWinner() 
     * returns a winner or a draw, or if the specified depth to be searched has 
     * been reached (ie, depth === 0).
     *
     * Otherwise, negamax() calls itself again: for each possible speculative 
     * move, it marks the board, recurses, then undoes the move, returning the 
     * highest score found.
     **/
 
    function negamax(gamestateCopy, player, depth) {
        var i,
            winner,
            bestScore = -9999,
            score,
            nextMove,
            possibleMoves = [],
            MOVES;

        winner = checkWinner(gamestateCopy);
        
        if (winner) {
            if (winner === player) return 1;
            else if (winner === draw) return 0;
            else return -1;
        } else if (!winner && depth == 0) {
            return 5;  // for immediate win/loss checking 
            
        } else {
            possibleMoves = getOpenSquares(gamestateCopy);
            MOVES = possibleMoves.length;

            // toggle between players
            if (player === computer) player = user;
            else player = computer;

            // make each speculative move, recurse, & undo move
            for (i = 0; i < MOVES; i++) {

                gamestateCopy[possibleMoves[i]] = player;
                score = -negamax(gamestateCopy, player, depth - 1);
                gamestateCopy[possibleMoves[i]] = '-';

                if (score > bestScore) {
                    bestScore = score;
                }
            }
            return bestScore;
        }
    }
}())
